---
title : Coroutine
author : YS_AN
date : 2023-10-14 10:09:00 +0900
categories : [Unity, UnityInfo]
tags : [Unity, 기술면접]
---

# Coroutine
실행을 일시 중지하고 Unity에 제어 권한을 반환한 후 다음 프레임에서 중단했던 위치에서 계속할 수 있는 메서드이다. <br/>
작업을 다수의 프레임에 분산할 수 있다. → 단일 스레드 환경인 유니티에서 비동기 처리가 필요할 때 활용한다. <br/><br/>
**주의**   <br/>
<span style='background-color:#FBECDD'>비동기 처럼 동작하지만 비동기 방식은 아니다.</span> <br/>
멀티 스레딩 모델의 비동기 방식은 병렬로 처리되기 때문에 함수 A의 완료와 함수 B의 실행 시점이 일치하지 않지만, <br/>
코루틴에서는 순차적으로 처리된다. (코루틴에서 작업이 늦을수록 다음 작업도 딜레이되는 현상이 발생하는 이유이기도 하다) <br/><br/>

> 동기식(Synchronous) VS 비동기식(Asynchronous)
> * 동기식 : 먼저 시작된 하나의 작업이 끝날 때까지 다른 작업을 시작하지 않고, 기다렸다가 다 끝난 후 새로운 작업을 시작하는 방식
> * 비동기식 : 먼저 시작된 작업의 완료 여부와 상관없이 새로운 작업을 시작하는 방식

> 비동기식 VS 멀티스레딩
> (비동기와 멀티스레딩 방식 정리)


### 코루틴 구현 
IEnumerator를 사용하여 작성되며 yield return으로 멈춘 시점에서 다시 시작한다. 
```C#
IEnumerator 함수이름()
{
	yield return // + 조건
    // 함수 내용
}
```

### 코루틴 내부 동작



장점
* 비동기식 처리가 가능하다 
* 프레임 독립적: 코루틴은 프레임 독립적입니다. 필요한 순간에 언제든지 게임 로직을 시작하고 일시 중지할 수 있다. 

단점
* 메모리 낭비 : 코루틴을 실행할 때마다 IEnumerator 인터페이스에 대한 객체가 생성된다. 코루틴 생성마다 새로운 가비지(IEnumerator)를 만들어내어 과도한 사용은 메모리 부담을 초래할 수 있다. 
* 코드 복잡성 : 코루틴을 오용하면 코드가 복잡해질 수 있습니다. → 지나치게 중첩된 코루틴은 유지 관리와 디버깅을 어렵게 만들 수 있다.

 
### UniTask

